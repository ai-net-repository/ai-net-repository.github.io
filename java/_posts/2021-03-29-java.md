# 자바(Java)

C 언어에 객체지향을 추가하여 만든 C++ 과는 달리 처음부터 객체지향 언어로 개발된 프로그래밍 언어이다.

자바는 JVM(Java Virtual Machine)을 사용하여, 운영체제와 독립적으로 동작할 수 있다.

## JVM(Java Virtual Machine) 이란?

JVM 을 통해 OS에 구애받지 않고 Java가 동작할 수 있게 해준다.

즉, java 와 OS 사이에서 중개자 역할을 한다.

메모리 관리, GC(Garbage Collection)을 수행한다.

JVM은 스택기반 가상머신이다.

### java 프로그램 실행 과정

1. JVM은 OS로 부터 프로그램이 필요로 하는 메모리를 할당 받는다.

2. java 컴파일러(javac)가 java 소스코드(.java)를 읽어들여 자바 바이트코드(.class)로 변환 시킨다.

3. Class Loader를 통해 class 파일을 JVM으로 로딩한다.

4. 로딩된 class파일들은 Execution engine을 통해 해석된다.

5. 해석된 바이트 코드는 Runtime Data Areas에 실질적인 수행이 이뤄진다.

   이러한 실행과정 속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업을 수행한다.

   



![자바 프로그램의 실행 순서](\images\img_java_programming.png)

#### 자바 컴파일러( java compiler )

java 컴파일러는 java를 가지고 작성한 java 소스코드를 자바 가상 머신이 이해할 수 있는 자바 바이트 코드로 변환합니다.

#### 자바 바이트 코드( Java bytecode )

자바 바이트 코드(Java bytecode)란 JVM이 이해할 수 있는 언어로 변환된 java 소스코드를 의미한다.

java 컴파일러에 의해 변환되는 코드의 명령어 크기가 1byte라서 java 바이트 코드로 불린다.

확장자는 .class 이며 JVM만 설치되어 있으면 어떤 OS라도 실행이 가능하다.

자바 바이트 코드는 기계가 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다.

#### 클래스 로더 ( class Loader )

자바 클래스 들은 시작 시 한번에 로드되지 않고, 애플리케이션에서 필요할 때 로드된다.

클래스 로더는 JRE(java Runtime Environment)의 일부로써 런타임에 동적으로 JVM에 로드 하는 역할을 수행하는 모듈이다.

##### 종류

1. 부트스트랩 클래스 로더(Bootstrap classloader)

   JVM 시작시 가장 최초로 실행되는 클래스 로더

   자바 클래스를 로드할 수 있는 자바 자체의 클래스로더와 최소한의 자바클래스(java.lang.Object, Class, Classloader) 만을 로드한다.

   부모 클래스로더를 갖지 않기 때문에 원시 클래스로더Primordial classloader)라고도 불린다.

2. 확장 클래스 로더

   부트스트랩 클래스로더를 부모로 같으 클래스로더

   확장 자바클래스들을 로드한다. 환경변수에 설정된 디렉토리의 클래스 파일을 로드하고 이값이 없을 경우 ${JAVA_HOME}/jre/lib/ext 에 있는 클래스 파일을 로드한다.

3. 애플리케이션 클래스 로더

   자바 프로그램 실행 시 지정한 Classpath에 있는 클래스 파일 혹은 Jar에 속한 클래스들을 로드한다.

##### 새로운 클래스틑 로드할 때

###### delegate Principle

클래스 로딩이 필요한 경우 부모 클래스 로더 방향으로 클래스 로딩을 위임한다.

1. JVM의 Method Area에 클래스가 로드되어있는지 확인.
2. 1번에서 찾지 못했을 경우 애플리케이션 클래스 로더에 요청
3. 애플리케이션 클래스로더는 확장 클래스로더에 클래스를 요청
4. 확장 클래스 로더는 부트스트랩 클래스로드에 요청
5. 부트스트랩 클래스 로더는 부트스트랩 ClassPath(JDK/JRE/LIB) 에 해당 클래스가 있는지 확인
6. 5번에서도 못찾으면 확장클래스 로더에 요청 확장 클래스 로더는 확장 ClassPath(JDK/JRE/LIB/EXT)에 해당 클래스가 있는지 확인
7. 6번에서도 찾지 못하면 애플리케이션 클래스로더는 애플리케이션 ClassPath에 해당 클래스가 있는지 확인한다.
8. 7번까지도 찾지 못하면 ClassNotFoundException을 발생시킨다.

#### Execution Engine(실행 엔진)

클래스를 실행 시키는 역할. 클래스 로더가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 실행엔진은 이를 실행한다. 실행 엔진은 이와 같은 바이트 코드를 실제로 JVM내부에서 기계가 실행할 수 있는 형태로 변경한다.

##### Interpreter(인터프리터)

실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다. 

인터프리터 언어는 한줄 씩 수행하는 방식이기 때문에 느리다.

##### JIT(Just - In - Time)

인터프리터의 방식을 보안하기 위해 도입된 JIT 컴파일러이다.

인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 더이상 인터프리팅을 하지 않고 네이티브 코드로 직접 실행하는 방식이다.

네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행하게 된다. 

JIT 컴파일러가 컴파일 하는 과정은 바이트 코드를 인터프리팅 하는 과정보다 훨씬 오래걸리기 때문에 한번만 실행되는 코드라면 컴파일 하지 않고 인터프리팅하는 것이 유리하다.

따라서 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 사용되는지 체크하고, 일정 빈도 이상의 코드를 컴파일 한다.

JIT 컴파일러는 OS마다 다르다.

*네이티브 코드? OS에 종속적으로 OS에서 실행할 수 있는 코드?

#### Garbage collector

GC를 수행하는 모듈

##### Runtime Data Area

프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간

![275A103F576B85550D](\images\275A103F576B85550D.jpg)

1. PC Register

   Thread가 어떤 부분을 어떤 명령으로 실행할 지에 대한 기록을 하는 부분 현재 수행중인 JVM 명령의 주소를 가진다.

2. JVM 스택 영역

   각종 형태의 변수, 임시데이터, 메소드의 정보를 저장한다. 메서드 수행이 끝나면 프레임( {}괄호로 쌓여있는 영역 ) 별로 삭제를 한다. heap에 있는 객체에 접근 할 수 있다.

3. Native method stack

   자바 프로그램이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행 시키는 영역. 

   Java가 아닌 다른 언어로 작성된 코드를 위한 공간. 

   Java Native Interface를 통해 바이트코드로 전환하여 저장하게 된다.

   일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역.

   이 부분을 통해 C code를 실행시켜 Kernel에 접근할 수 있다.

   *Kernel? 소프트웨어와 하드웨어간의 커뮤니 케이션을 관리하는 프로그램

4. Method Area ( = Class area = Static = area )

   클래스 정보를 처음 메모리 공간에 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간.

   JVM은 해당 클래스 파일을 읽어서 클래스 인스턴스변수, 메소드 코드 등을 Method Area에 저장한다.

5. Heap 영역

   객체를 저장하는 가상 메모리 공간.

출처 : https://leeyh0216.github.io/2020-04-18/java_class_loader

출처 : https://asfirstalways.tistory.com/158

출처 : http://www.tcpschool.com/java/java_intro_programming